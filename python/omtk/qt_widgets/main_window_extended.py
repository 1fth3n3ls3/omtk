import logging
from omtk.vendor.Qt import QtCore, QtWidgets, QtGui

from .ui import main_window_extended

log = logging.getLogger('omtk')

# from omtk.vendor import pyvfxboilerplate


class MainWindowExtended(QtWidgets.QMainWindow):
    def __init__(self):
        super(MainWindowExtended, self).__init__()
        self._is_built = False  # prevent our custom setStatusBar from being run while the UI is being built...
        self.ui_logger = main_window_extended.Ui_MainWindow()
        self.ui_logger.setupUi(self)
        self._is_built = True

        # Makes Maya perform magic which makes the window stay
        # on top in OS X and Linux. As an added bonus, it'll
        # make Maya remember the window position
        # src: https://github.com/fredrikaverpil/pyvfx-boilerplate/blob/master/boilerplate.py#L110
        self.setProperty("saveWindowPref", True)

        # Ensure that QWidgets are destroyed when the QMainWindow is closed.
        # We have destroyed events connected in the code that need to be fired and this only
        # seem fixable in the QMainWindow itself.
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)

        self._configure_widget_logger()

        self.set_logger(log)

    def set_logger(self, logger):
        self.ui_logger.widget_logger.set_logger(logger)

    def _configure_widget_logger(self):
        # Configure logger and status-bar
        self.ui_logger.dockWidget_logger.hide()
        self.ui_logger.widget_logger.onRecordAdded.connect(self.update_status_bar)

        # Hack: Skip subclassing QDockWidget to modify closeEvent
        def _logger_close_event(e):
            self.update_status_bar(force_show=True)
            e.accept()

        self.ui_logger.dockWidget_logger.closeEvent = _logger_close_event

    def setStatusBar(self, statusbar):
        """
        Override QMainWindow.setStatusBar so handles are correctly added.
        :param statusbar:
        :return:
        """
        # todo: remove old handlers?
        super(MainWindowExtended, self).setStatusBar(statusbar)

        # We have no guarantee that the code generated by pysideuic will set the statusBar last.
        # This mean that we might not be able to update the UI correctly the first time the UI is built.
        if not self._is_built:
            return

        # Hack: Skip subclassing QStatusBar to modify mousePressEvent
        def _status_bar_mouse_press_event(e):
            self.ui_logger.dockWidget_logger.show()
            self.update_status_bar()

        statusbar.mousePressEvent = _status_bar_mouse_press_event
        self.update_status_bar()

    def update_status_bar(self, force_show=False):
        statusbar = self.statusBar()

        # No need for the status bar if the logger is visible
        if self.ui_logger.widget_logger.isVisible() and not force_show:
            statusbar.setStyleSheet('')
            statusbar.showMessage('')
            return

        # If the logger is now visible, the status bar will resume the logs.
        num_errors = 0
        num_warnings = 0
        num_infos = 0
        num_debug = 0
        model = self.ui_logger.widget_logger.model()
        for entry in model.items:
            if entry.levelno >= logging.ERROR:
                num_errors += 1
            elif entry.levelno >= logging.WARNING:
                num_warnings += 1
            elif entry.levelno >= logging.INFO:
                num_infos += 1
            elif entry.levelno >= logging.DEBUG:
                num_debug += 1

        # Define style
        stylesheet = ''
        if num_errors:
            stylesheet = "background-color: rgb(255, 000, 000); color: rgb(0, 0, 0);"
        elif num_warnings:
            stylesheet = "background-color: rgb(200, 200, 128); color: rgb(0, 0, 0);"
        statusbar.setStyleSheet(stylesheet)

        # Define message
        messages = []
        if num_errors:
            messages.append('{0} error messages'.format(num_errors))
        elif num_warnings:
            messages.append('{0} warning messages'.format(num_warnings))
        elif num_infos:
            messages.append('{0} info messages'.format(num_infos))
        elif num_debug:
            messages.append('{0} debug messages'.format(num_debug))
        else:
            statusbar.setStyleSheet("")

        if messages:
            statusbar.showMessage(', '.join(messages))

    def closeEvent(self, *args):
        try:
            self.ui_logger.widget_logger.remove_logger_handler()
        except Exception, e:
            log.warning("Error removing logging handler: {0}:".format(e))
        super(MainWindowExtended, self).closeEvent(*args)
