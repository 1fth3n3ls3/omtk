Development
~~~~~~~~~~~

BaseName Class
==============

The BaseName class handle naming of object generated by OMTK.
The approach try to be generic and support any possible nomenclature a studio can have.

Tokens
------
A name in OMTK is composed of *tokens*.
Since there no real encapsulation in Maya, it is good usage to "suggest" encapsulation with tokens.
Let's say we have an Spine composed of an hybrid IK/FK system.

- spine_ik_locator
- spine_fk_locator

Using token to suggest encapsulation, we can easily see which locator is part of which system.
Note that hyerarchy in Maya can also suggest encapsulation, however it is often used for other purpose like organization and controlling transforms.

Suffixes
---------------------
It is common to see studio nomenclature where a specific token is always at the end.
For example, lets say that any element that is part of the rig logic always end with "_rig".

    >>> name = BaseName(tokens=['spine', 'ik'], suffix='rig')
    >>> name.resolve('locator')
    'spine_ik_locator_rig'

.. tip:: When subclassing BaseName, you can define what token will be reconized as a suffix by defining the KNOWN_SUFFIX static property.

Side
----
Side is a special token that is handled by the implementation of BaseName.
It is generally defined as left or right but can also support any other variation like middle/upp/low/etc.
When subclassing BaseClass to implement new side, you'll want to look at get_side_from_token().

Here's an example of subclass that implement the 'M' side for 'Middle':

    >>> class CustomName(BaseName):
    ...     SIDE_L = 'l'
    ...     SIDE_R = 'r'
    ...     SIDE_M = 'm'
    ...     KNOWN_SIDES = [SIDE_L, SIDE_R, SIDE_M]
    ...
    >>> nomenclature = CustomName(tokens=('spine', 'ik'), side=CustomName.SIDE_L)
    >>> nomenclature.resolve('locator')
    'spine_ik_locator_l'

Separators
----------

TODO

Here's an example of a subclass that implement separators using PascalCase.

Plugin Management
=================
OMTK feature a Plugin Manager that allow studios to create and manage their own plugins without needing to hijack the core or distribute them. The Plugin Manager is simple and use the pkgutil Python module as fundation.

Creating Plugins
--------------
You can currently create two types of plugins.

- Modules
- Rigs

Simply create the following hierarchy somewhere on a location on disk:

- omtk
    - modules
        - __init__.py
    - rigs
        - __init__.py

Then, add the path to the path to that location to the OMTK_PLUGINS environment variable.
Any modules or rigs that you will define in this hierarchy will be added to OMTK library.
Here's the most basic example of a module implementation.

Located at {location}/omtk/modules/FlyingSaucer.py

.. code-block:: python
   :linenos:

   from omtk.core.classModule import Module
   
   class FlyingSaucer(Module):
       pass

   def register_plugin():
       return FlyingSaucer

Defining a register_plugin function that return your module class definition is the only prerequisite to have your plugin running.

Debugging Plugins
-----------------

Do see if your plugin is loaded correctly, you can use the GUI or run the following command:

    >>> from omtk.core import plugin_manager
    >>> pm = plugin_manager.plugin_manager
    >>> pm.get_summary()

When you do changes to your code, you can either re-open the GUI or run the following command:

    >>> from omtk.core import plugin_manager
    >>> pm = plugin_manager.plugin_manager
    >>> pm.reload_all(force=True)
